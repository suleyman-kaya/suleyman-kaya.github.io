<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<title>Görsel Örüntü Tamamlama Oyunu</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root {
    --cell: 52px;
    --gap: 12px;
    --accent: #0aa7ff;
    --board-border: 3px solid #111;
  }
  * { box-sizing: border-box; }

  body {
    font-family: "Segoe UI", Roboto, Arial, sans-serif;
    background: #f6f6f6;
    margin: 20px;
    color: #111;
    line-height: 1.5;
  }
  h1 { text-align: center; margin-bottom: 6px; color: #222; }

  .top-bar { display:flex; gap:12px; align-items:center; justify-content:center; margin-bottom:20px; flex-wrap:wrap; }
  select, input[type=number] { padding:8px; font-size:14px; border:1px solid #ccc; border-radius:4px; }
  button { padding:10px 14px; font-size:14px; cursor:pointer; background:var(--accent); color:white; border:0; border-radius:4px; transition:background .2s; }
  button:hover { background:#0088dd; }

  .container { display:flex; gap:30px; align-items:flex-start; justify-content:center; flex-wrap:wrap; }
  .sequence { background:white; padding:20px; border-radius:10px; box-shadow:0 6px 18px rgba(0,0,0,0.08); min-width:300px; }

  .frames { display:flex; gap:15px; flex-wrap:nowrap; justify-content:flex-start; margin-bottom:20px; overflow-x:auto; padding-bottom:6px; }
  .frame { width: calc(var(--cell) * 4 + 16px); padding:8px; background:#fff; border:var(--board-border); border-radius:6px; display:grid; grid-template-columns:repeat(4,var(--cell)); grid-template-rows:repeat(4,var(--cell)); box-sizing:border-box; flex:0 0 auto; }
  .placeholder { width: calc(var(--cell) * 4 + 16px); height: calc(var(--cell) * 4 + 16px); display:flex; align-items:center; justify-content:center; border:3px dashed #bbb; background:#fafafa; border-radius:6px; cursor:pointer; transition:border-color .2s; box-sizing:border-box; padding:8px; flex:0 0 auto; }
  .placeholder:hover { border-color:var(--accent); background:#f0f8ff; }

  .grid-cell { width:var(--cell); height:var(--cell); box-sizing:border-box; border:1px solid #eee; position:relative; overflow:hidden; display:flex; align-items:center; justify-content:center; }
  .glyph { display:inline-block; font-family:"Segoe UI Symbol", "Noto Color Emoji", "Segoe UI", "Arial Unicode MS", sans-serif; font-size:calc(var(--cell) * 0.62); line-height:1; transform-origin:center center; user-select:none; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; -webkit-text-stroke:0.6px rgba(0,0,0,0.12); }

  .glyph.square { color:#ffcc66; }
  .glyph.triangle { color:#7bd389; }
  .glyph.circle { color:#ff6666; }
  .glyph.hex { color:#66aaff; }

  .sidebar { width:320px; display:grid; grid-template-columns:1fr 1fr; gap:10px; align-content:start; }
  .option { width: calc(var(--cell) * 4 + 16px); height: calc(var(--cell) * 4 + 16px); border:2px solid #ddd; background:white; display:grid; grid-template-columns:repeat(4,var(--cell)); grid-template-rows:repeat(4,var(--cell)); cursor:pointer; border-radius:6px; transition:transform .2s, box-shadow .2s; box-sizing:border-box; padding:0; align-items:start; flex:0 0 auto; }
  .option:hover { transform:translateY(-2px); box-shadow:0 4px 8px rgba(0,0,0,0.1); }
  .option.selected { outline:4px solid rgba(0,170,255,0.3); border-color:var(--accent); box-shadow:0 6px 12px rgba(0,0,0,0.08); }

  .controls-bottom { margin-top:20px; text-align:center; }
  #result { margin-top:15px; padding:10px; border-radius:5px; font-weight:600; min-height:24px; }
  .meta { font-size:14px; color:#444; text-align:center; margin:10px 0; padding:10px; background:#f8f9fa; border-radius:5px; }

  footer { text-align:center; margin-top:30px; color:#666; font-size:13px; padding-top:15px; border-top:1px solid #eee; }

  @media (max-width:768px){ .container{flex-direction:column; align-items:center;} .sidebar{width:100%; max-width:300px;} .option{width:calc(var(--cell)*4+12px); height:calc(var(--cell)*4+12px);} .frame,.placeholder{width:calc(var(--cell)*4+12px); height:calc(var(--cell)*4+12px);} }
</style>
</head>
<body>
  <h1>Görsel Örüntü Tamamlama Oyunu</h1>

  <div class="top-bar">
    <label>Seviye:
      <select id="difficulty">
        <option value="easy">Basit (Zorluk 1)</option>
        <option value="medium">Orta (Zorluk 2)</option>
        <option value="hard">Zor (Zorluk 3)</option>
        <option value="veryhard">Çok Zor (Zorluk 4)</option>
        <option value="expert">Uzman (Zorluk 5)</option>
        <option value="master">Usta (Zorluk 6)</option>
      </select>
    </label>
    <label>Seed (opsiyonel):
      <input id="seed" type="number" placeholder="123" min="1" max="999999" />
    </label>
    <button id="newBtn">Yeni Soru</button>
  </div>

  <div class="container">
    <div class="sequence">
      <div class="frames" id="framesWrap"></div>
      <div class="meta"><span id="ruleText"></span></div>

      <div class="controls-bottom">
        <button id="checkBtn">Cevabı Kontrol Et</button>
        <button id="explainBtn" style="background:#666;">Açıkla</button>
        <div id="result"></div>
      </div>
    </div>

    <div class="sidebar" id="optionsWrap"></div>
  </div>

  <footer>Görsel örüntü tamamlama oyunu - Mantıksal akıl yürütme becerilerinizi test edin</footer>

<script>
// --- Utility ---
function makeRng(seed) {
  if (!seed) return Math.random;
  let s = Number(seed) || 1;
  return function() { s = (s * 1664525 + 1013904223) | 0; return (s >>> 0) / 4294967296; };
}
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function deepCopy(o){ return JSON.parse(JSON.stringify(o)); }
function letterToX(letter){ return letter.toUpperCase().charCodeAt(0) - 65; }

// 4x4 GRID
const GRID = { w:4, h:4 };
const SHAPE_GLYPHS = { square:'➤', triangle:'▲', circle:'♥', hex:'♣' };

// --- Normalization & comparison helpers ---
function normalizeObj(o){
  const obj = { ...o };
  obj.x = Math.round(Number(obj.x) || 0);
  obj.y = Math.round(Number(obj.y) || 0);
  obj.x = clamp(obj.x, 0, GRID.w-1);
  obj.y = clamp(obj.y, 0, GRID.h-1);
  obj.rot = Math.round(Number(obj.rot) || 0);
  obj.rot = ((obj.rot % 360) + 360) % 360;
  if (obj.visible === undefined) obj.visible = true;
  if (!obj.shape) obj.shape = 'square';
  if (!obj.color) obj.color = '';
  return obj;
}
function normalizeFrame(frame){
  if (!Array.isArray(frame)) return [];
  return frame.map(normalizeObj);
}
function normalizeObjectsForKey(objs){
  const arr = normalizeFrame(objs).map(o=>{
    return { shape:o.shape, x:o.x, y:o.y, rot:o.rot, visible:!!o.visible, color:o.color||'' };
  });
  arr.sort((a,b)=>{
    if(a.shape!==b.shape) return a.shape.localeCompare(b.shape);
    if(a.color!==b.color) return (a.color||'').localeCompare(b.color||'');
    if(a.x!==b.x) return a.x-b.x;
    if(a.y!==b.y) return a.y-b.y;
    return a.rot-b.rot;
  });
  return arr;
}
function frameKey(frame){ return JSON.stringify(normalizeObjectsForKey(frame)); }
function eqObjects(a,b){
  if(!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) return false;
  const A = normalizeObjectsForKey(a), B = normalizeObjectsForKey(b);
  if(A.length !== B.length) return false;
  for(let i=0;i<A.length;i++){
    const pa = A[i], pb = B[i];
    if(pa.shape !== pb.shape) return false;
    if(pa.x !== pb.x) return false;
    if(pa.y !== pb.y) return false;
    if(pa.rot !== pb.rot) return false;
    if(pa.visible !== pb.visible) return false;
    if((pa.color||'') !== (pb.color||'')) return false;
  }
  return true;
}
function isValidFrame(frame, expectedCount=null){
  if(!Array.isArray(frame) || frame.length === 0) return false;
  const norm = normalizeFrame(frame);
  const hasVisible = norm.some(o=> o.visible !== false);
  if(!hasVisible) return false;
  if(expectedCount !== null && norm.length !== expectedCount) return false;
  return true;
}

// --- New: ensure unique positions by relocating colliding objects ---
// find nearest free cell (BFS by Manhattan radius)
function findNearestFreePosition(occupiedSet, startX, startY){
  const key = (x,y) => `${x},${y}`;
  if(!occupiedSet.has(key(startX,startY))) return { x:startX, y:startY };
  // BFS by increasing manhattan radius
  for(let r=1; r<=Math.max(GRID.w, GRID.h); r++){
    for(let dx=-r; dx<=r; dx++){
      const dy = r - Math.abs(dx);
      const candidates = [
        { x: startX + dx, y: startY + dy },
        { x: startX + dx, y: startY - dy }
      ];
      for(const c of candidates){
        if(c.x < 0 || c.x >= GRID.w || c.y < 0 || c.y >= GRID.h) continue;
        if(!occupiedSet.has(key(c.x,c.y))) return { x:c.x, y:c.y };
      }
    }
  }
  // fallback: find any free cell
  for(let y=0;y<GRID.h;y++){
    for(let x=0;x<GRID.w;x++){
      if(!occupiedSet.has(key(x,y))) return { x, y };
    }
  }
  // none free
  return null;
}

// ensureUniquePositions: for given frame array, ensure no two objects share same (x,y)
function ensureUniquePositions(frame){
  const norm = normalizeFrame(frame);
  const occupied = new Set();
  const key = (x,y) => `${x},${y}`;
  const result = [];
  for(const obj of norm){
    let tx = obj.x, ty = obj.y;
    if(occupied.has(key(tx,ty))){
      // find nearest free
      const free = findNearestFreePosition(occupied, tx, ty);
      if(free){
        tx = free.x; ty = free.y;
      } else {
        // can't find free (all occupied), keep original (will overlap, but rare)
      }
    }
    occupied.add(key(tx,ty));
    const placed = { ...obj, x: tx, y: ty };
    result.push(placed);
  }
  return result;
}

// --- Rendering ---
function renderShape(obj){
  const span = document.createElement('span');
  span.className = 'glyph ' + (obj.shape || 'square');
  span.textContent = SHAPE_GLYPHS[obj.shape] || '?';
  span.style.transform = obj.rot ? `rotate(${obj.rot}deg)` : '';
  if(obj.color) span.style.color = obj.color;
  return span;
}

function createFrameGrid(objects){
  const container = document.createElement('div');
  container.className = 'frame';
  const norm = ensureUniquePositions(objects);
  // create a 4x4 iteration; only one object per cell by design
  for(let y=0;y<GRID.h;y++){
    for(let x=0;x<GRID.w;x++){
      const cell = document.createElement('div');
      cell.className = 'grid-cell';
      // find object at this coord (there will be at most one)
      for(const obj of norm){
        if(obj.x === x && obj.y === y && obj.visible !== false){
          cell.appendChild(renderShape(obj));
          break;
        }
      }
      container.appendChild(cell);
    }
  }
  return container;
}

function createPlaceholder(index){
  const placeholder = document.createElement('div');
  placeholder.className = 'placeholder';
  placeholder.dataset.index = index;
  placeholder.innerHTML = '<div style="font-size:24px;color:#777;">?</div>';
  placeholder.addEventListener('click', ()=>{
    if(currentState.selectedOption !== null) placeOptionInBlank(currentState.selectedOption, index);
  });
  return placeholder;
}

function createOptionGrid(objects, index){
  const option = document.createElement('div');
  option.className = 'option';
  option.dataset.index = index;
  const norm = ensureUniquePositions(objects);
  for(let y=0;y<GRID.h;y++){
    for(let x=0;x<GRID.w;x++){
      const cell = document.createElement('div');
      cell.className = 'grid-cell';
      for(const obj of norm){
        if(obj.x === x && obj.y === y && obj.visible !== false){
          cell.appendChild(renderShape(obj));
          break;
        }
      }
      option.appendChild(cell);
    }
  }
  option.addEventListener('click', ()=>{
    document.querySelectorAll('.option').forEach(o=> o.classList.remove('selected'));
    option.classList.add('selected');
    currentState.selectedOption = index;
  });
  return option;
}

// --- Distractors generator (preserve object count, and then ensureUniquePositions) ---
function makeDistractorsForFrame(correctFrame, rng, max=5){
  const distractors = [];
  const attempts = max * 8;
  const baseCount = (Array.isArray(correctFrame) ? correctFrame.length : 0);
  for(let i=0;i<attempts && distractors.length < max;i++){
    const variant = deepCopy(correctFrame).map(o=>{
      const v = {...o};
      const mod = Math.floor(rng()*5);
      switch(mod){
        case 0:
          v.x = clamp(v.x + choose([-1,0,1], rng), 0, GRID.w-1);
          v.y = clamp(v.y + choose([-1,0,1], rng), 0, GRID.h-1);
          break;
        case 1:
          v.shape = choose(['square','triangle','circle','hex'].filter(s=>s!==v.shape), rng);
          break;
        case 2:
          v.rot = ((v.rot || 0) + 90 * (1 + Math.floor(rng()*3))) % 360;
          break;
        case 3:
          if(rng()>0.5){ v.x = clamp(v.x + choose([-1,1], rng),0,GRID.w-1); v.y = clamp(v.y + choose([-1,1], rng),0,GRID.h-1); }
          break;
        case 4:
          v.color = v.color || '';
          if(!v.color) v.color = choose(['white','goldenrod','green','hotpink','red','black'], rng);
          break;
      }
      return v;
    });
    // ensure disambiguation by relocating overlaps
    const candidate = ensureUniquePositions(variant);
    if(isValidFrame(candidate, baseCount) && !eqObjects(candidate, correctFrame) && !distractors.some(d=>eqObjects(d, candidate))){
      distractors.push(candidate);
    }
  }
  return distractors;
}

function choose(arr, rng){ return arr[Math.floor(rng()*arr.length)]; }

// --- Generators (adjusted for 4x4, then ensureUniquePositions applied) ---
function clampLetterToAtoD(letter){
  const x = letterToX(letter);
  return String.fromCharCode(65 + clamp(x, 0, 3));
}

function genLevel1(rng){
  const letters = ['B','B','B','B','B','B'];
  const rows = [2,1,2,3,4,3];
  const sheets=[];
  for(let i=0;i<6;i++){
    const col = clampLetterToAtoD(letters[i]);
    const row = clamp(rows[i],1,4);
    sheets.push([{ id:'A', shape:'triangle', x:letterToX(col), y:row-1, rot:0, visible:true, color:'green' }]);
  }
  return { frames: sheets.slice(0,4).map(s=>ensureUniquePositions(s)), correct:[ensureUniquePositions(sheets[4]), ensureUniquePositions(sheets[5])], ruleText:"Zorluk 1: Tek cisim, dikey (B sütunu) salınım. 4x4 grid." };
}

function genLevel2(rng){
  const letters=['A','B','C','B','A','B'];
  const rows=[3,2,1,2,3,2];
  const sheets=[];
  for(let i=0;i<6;i++){
    const col = clampLetterToAtoD(letters[i]);
    const row = clamp(rows[i],1,4);
    sheets.push([{ id:'A', shape:'square', x:letterToX(col), y:row-1, rot:0, visible:true, color:'goldenrod' }]);
  }
  return { frames: sheets.slice(0,4).map(s=>ensureUniquePositions(s)), correct:[ensureUniquePositions(sheets[4]), ensureUniquePositions(sheets[5])], ruleText:"Zorluk 2: Tek cisim (sarı), V şeklinde salınım. 4x4 grid." };
}

function genLevel3(rng){
  const c2Letters=['D','D','C','B','A','A']; const c2Rows=[2,1,1,1,1,2];
  const c1Letters=['C','C','B','B','C','C']; const c1Rows=[3,4,4,3,2,3];
  const sheets=[];
  for(let i=0;i<6;i++){
    const c1col = clampLetterToAtoD(c1Letters[i]);
    const c2col = clampLetterToAtoD(c2Letters[i]);
    sheets.push([
      { id:'A', shape:'hex', x:letterToX(c1col), y:clamp(c1Rows[i]-1,0,3), rot:0, visible:true, color:(i%2===0?'black':'hotpink') },
      { id:'B', shape:'square', x:letterToX(c2col), y:clamp(c2Rows[i]-1,0,3), rot:0, visible:true, color:'goldenrod' },
      { id:'C', shape:'triangle', x:1, y:1, rot: (0 + 90*i) % 360, visible:true, color:'white' }
    ]);
  }
  return { frames: sheets.slice(0,4).map(s=>ensureUniquePositions(s)), correct:[ensureUniquePositions(sheets[4]), ensureUniquePositions(sheets[5])], ruleText:"Zorluk 3: Çoklu cisimler. cisim3 her sheet'te +90°." };
}

function genLevel4(rng){
  const c1Letters=['D','C','C','A','C','B']; const c1Rows=[1,2,3,4,3,3];
  const c2Letters=['C','B','B','C','C','B']; const c2Rows=[3,3,2,2,4,3];
  const sheets=[];
  for(let i=0;i<6;i++){
    const c1col = clampLetterToAtoD(c1Letters[i]);
    const c2col = clampLetterToAtoD(c2Letters[i]);
    sheets.push([
      { id:'A', shape:'circle', x:letterToX(c1col), y:clamp(c1Rows[i]-1,0,3), rot:0, visible:true, color:'white' },
      { id:'B', shape:'hex', x:letterToX(c2col), y:clamp(c2Rows[i]-1,0,3), rot:0, visible:true, color:'hotpink' },
      { id:'C', shape:'triangle', x:1, y:1, rot:(0+90*i)%360, visible:true, color:'green' }
    ]);
  }
  return { frames: sheets.slice(0,4).map(s=>ensureUniquePositions(s)), correct:[ensureUniquePositions(sheets[4]), ensureUniquePositions(sheets[5])], ruleText:"Zorluk 4: Bir cisim döner, diğerleri hareket eder. 4x4 grid." };
}

function genLevel5(rng){
  const c1Letters=['B','C','C','D','C','B']; const c1Rows=[1,1,2,2,3,3];
  const c2Letters=['D','D','C','B','A','A']; const c2Rows=[4,4,3,2,1,2];
  const c3Letters=['A','A','A','A','A','A']; const c3Rows=[1,2,3,4,4,4];
  const c4Letters=['D','D','D','D','D','D']; const c4Rows=[1,1,2,2,3,3];
  const sheets=[];
  for(let i=0;i<6;i++){
    const aCol = clampLetterToAtoD(c1Letters[i]);
    const bCol = clampLetterToAtoD(c2Letters[i]);
    const cCol = clampLetterToAtoD(c3Letters[i]);
    const dCol = clampLetterToAtoD(c4Letters[i]);
    sheets.push([
      { id:'A', shape:'hex', x:clamp(letterToX(aCol),0,3), y:clamp(c1Rows[i]-1,0,3), rot:((-90*i)%360+360)%360, visible:true, color:(i%2? 'black':'hotpink') },
      { id:'B', shape:'square', x:clamp(letterToX(bCol),0,3), y:clamp(c2Rows[i]-1,0,3), rot:((-90*i)%360+360)%360, visible:true, color:(i%2? 'yellow':'white') },
      { id:'C', shape:'triangle', x:clamp(letterToX(cCol),0,3), y:clamp(c3Rows[i]-1,0,3), rot:0, visible:true, color:'white' },
      { id:'D', shape:'circle', x:clamp(letterToX(dCol),0,3), y:clamp(c4Rows[i]-1,0,3), rot:0, visible:true, color:'goldenrod' }
    ]);
  }
  return { frames: sheets.slice(0,4).map(s=>ensureUniquePositions(s)), correct:[ensureUniquePositions(sheets[4]), ensureUniquePositions(sheets[5])], ruleText:"Zorluk 5: Renk değişimi + negatif rotasyon. 4x4 grid." };
}

function genLevel6(rng){
  const c1Letters=['A','B','C','D','D','D']; const c1Rows=[1,1,2,2,3,3];
  const c2Letters=['D','D','C','B','A','A']; const c2Rows=[4,4,3,2,1,2];
  const c3Letters=['C','C','C','C','C','C']; const c3Rows=[3,3,3,3,3,3];
  const colorCycle=['goldenrod','green','red'];
  const sheets=[];
  for(let i=0;i<6;i++){
    const c1col = clampLetterToAtoD(c1Letters[i]);
    const c2col = clampLetterToAtoD(c2Letters[i]);
    const c3col = clampLetterToAtoD(c3Letters[i]);
    const c1color = (i%3===0?'red':(i%3===1?'darkred':'orangered'));
    const c4color = colorCycle[i % colorCycle.length];
    sheets.push([
      { id:'A', shape:'square', x:clamp(letterToX(c1col),0,3), y:clamp(c1Rows[i]-1,0,3), rot:(i*90)%360, visible:true, color:c1color },
      { id:'B', shape:'triangle', x:clamp(letterToX(c2col),0,3), y:clamp(c2Rows[i]-1,0,3), rot:((-90*i)%360+360)%360, visible:true, color:'white' },
      { id:'C', shape:'circle', x:clamp(letterToX(c3col),0,3), y:clamp(c3Rows[i]-1,0,3), rot:0, visible:true, color:'white' },
      { id:'D', shape:'hex', x:clamp(1 + (i%2),0,3), y:clamp(0 + Math.floor(i/2),0,3), rot:(90*i)%360, visible:true, color:c4color }
    ]);
  }
  return { frames: sheets.slice(0,4).map(s=>ensureUniquePositions(s)), correct:[ensureUniquePositions(sheets[4]), ensureUniquePositions(sheets[5])], ruleText:"Zorluk 6: Karmaşık renk/rotasyon kombinasyonları. 4x4 grid." };
}

function genQuestionFor(level, rng){
  switch(level){
    case 'easy': return genLevel1(rng);
    case 'medium': return genLevel2(rng);
    case 'hard': return genLevel3(rng);
    case 'veryhard': return genLevel4(rng);
    case 'expert': return genLevel5(rng);
    case 'master': return genLevel6(rng);
    default: return genLevel1(rng);
  }
}

// Build options ensuring both correct frames present exactly once and unique
function buildOptionsEnsuringCorrectPresence(question, rng){
  const targetOptions = 6;
  const uniqueMap = new Map();
  question.correct.forEach(cf=>{
    const k = frameKey(cf);
    if(!uniqueMap.has(k) && isValidFrame(cf)) uniqueMap.set(k, deepCopy(cf));
  });

  let attempts = 0;
  while(uniqueMap.size < targetOptions && attempts < 400){
    attempts++;
    const base = deepCopy(choose(question.correct, rng));
    const distractors = makeDistractorsForFrame(base, rng, 4);
    for(const d of distractors){
      if(uniqueMap.size >= targetOptions) break;
      const dk = frameKey(d);
      const equalsAnyCorrect = question.correct.some(cf => eqObjects(cf, d));
      if(equalsAnyCorrect) continue;
      if(!uniqueMap.has(dk) && isValidFrame(d, base.length)) uniqueMap.set(dk, d);
    }
  }

  attempts = 0;
  while(uniqueMap.size < targetOptions && attempts < 400){
    attempts++;
    const base = deepCopy(choose(question.correct, rng));
    const candidate = base.map(o=>({
      ...o,
      x: clamp(o.x + Math.floor(rng()*3) - 1, 0, GRID.w-1),
      y: clamp(o.y + Math.floor(rng()*3) - 1, 0, GRID.h-1),
      rot: ((o.rot || 0) + 90 * Math.floor(rng()*4)) % 360,
      color: o.color || ''
    }));
    const ck = frameKey(candidate);
    const equalsAnyCorrect = question.correct.some(cf => eqObjects(cf, candidate));
    if(!equalsAnyCorrect && !uniqueMap.has(ck) && isValidFrame(candidate, base.length)) uniqueMap.set(ck, candidate);
  }

  question.correct.forEach(cf=>{
    const k = frameKey(cf);
    if(!uniqueMap.has(k) && isValidFrame(cf)) uniqueMap.set(k, deepCopy(cf));
  });

  const arr = Array.from(uniqueMap.values());
  attempts = 0;
  while(arr.length < targetOptions && attempts < 200){
    attempts++;
    const base = deepCopy(choose(arr, rng));
    const candidate = base.map(o=>({
      ...o,
      x: clamp(o.x + choose([-1,0,1], rng), 0, GRID.w-1),
      y: clamp(o.y + choose([-1,0,1], rng), 0, GRID.h-1),
      rot: (o.rot||0) + 90*Math.floor(rng()*4)
    }));
    if(isValidFrame(candidate) && !arr.some(a=>eqObjects(a,candidate)) && !question.correct.some(cf=>eqObjects(cf,candidate))) arr.push(candidate);
  }

  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(rng()*(i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

// --- State & glue ---
let currentState = { level:'easy', frames:[], correct:[], options:[], ruleText:'', selectedOption:null, placedAnswers:[] };
const framesWrap = document.getElementById('framesWrap');
const optionsWrap = document.getElementById('optionsWrap');
const ruleTextEl = document.getElementById('ruleText');
const resultEl = document.getElementById('result');

function loadNewQuestion(){
  const level = document.getElementById('difficulty').value;
  const seedVal = document.getElementById('seed').value;
  const rng = makeRng(seedVal || Date.now());
  const question = genQuestionFor(level, rng);
  if(!question || !question.frames || !question.correct || question.correct.length === 0){
    const q = genLevel1(rng);
    currentState.frames = q.frames; currentState.correct = q.correct; currentState.ruleText = q.ruleText;
  } else {
    currentState.frames = question.frames;
    currentState.correct = question.correct;
    currentState.ruleText = question.ruleText;
  }
  currentState.correct = currentState.correct.map(cf => ensureUniquePositions(cf));
  currentState.options = buildOptionsEnsuringCorrectPresence(currentState, rng).map(f => ensureUniquePositions(f));
  currentState.correct.forEach(cf=>{
    if(!currentState.options.some(o=>eqObjects(o, cf))){
      currentState.options.unshift(deepCopy(cf));
    }
  });
  const unique = [];
  currentState.options.forEach(o=>{
    if(!unique.some(u=>eqObjects(u,o))) unique.push(o);
  });
  currentState.options = unique.slice(0,6);
  currentState.level = level;
  currentState.selectedOption = null;
  currentState.placedAnswers = new Array(currentState.correct.length).fill(null);
  renderQuestion();
}

function renderQuestion(){
  framesWrap.innerHTML = '';
  optionsWrap.innerHTML = '';
  currentState.frames.forEach(frame => framesWrap.appendChild(createFrameGrid(frame)));
  currentState.placedAnswers.forEach((_,i)=> framesWrap.appendChild(createPlaceholder(i)));
  currentState.options.forEach((opt,i)=> optionsWrap.appendChild(createOptionGrid(opt,i)));
  ruleTextEl.textContent = currentState.ruleText;
  resultEl.textContent = '';
  resultEl.style.color = '';
}

function placeOptionInBlank(optionIndex, blankIndex){
  currentState.placedAnswers[blankIndex] = deepCopy(currentState.options[optionIndex]);
  updatePlaceholders();
}

function updatePlaceholders(){
  const placeholders = framesWrap.querySelectorAll('.placeholder');
  placeholders.forEach((ph, idx)=>{
    const answer = currentState.placedAnswers[idx];
    if(answer){
      ph.innerHTML = '';
      const inner = createFrameGrid(answer);
      inner.style.border = 'none';
      inner.style.padding = '0';
      ph.appendChild(inner);
      ph.style.border = '3px solid #4CAF50';
      ph.style.background = '#f0fff0';
    } else {
      ph.innerHTML = '<div style="font-size:24px;color:#777;">?</div>';
      ph.style.border = '3px dashed #bbb';
      ph.style.background = '#fafafa';
    }
  });
}

// Check
document.getElementById('checkBtn').addEventListener('click', ()=>{
  const allFilled = currentState.placedAnswers.every(a => a !== null);
  if(!allFilled){ resultEl.textContent = 'Lütfen tüm boşlukları doldurun.'; resultEl.style.color = '#f44336'; return; }
  let allCorrect = true;
  for(let i=0;i<currentState.correct.length;i++){
    if(!eqObjects(currentState.placedAnswers[i], currentState.correct[i])){ allCorrect = false; break; }
  }
  if(allCorrect){ resultEl.textContent = '✅ Tebrikler! Doğru cevap.'; resultEl.style.color = '#4CAF50'; }
  else { resultEl.textContent = '❌ Yanlış cevap. Tekrar deneyin veya "Açıkla" butonuna basın.'; resultEl.style.color = '#f44336'; }
});

// Explain
document.getElementById('explainBtn').addEventListener('click', ()=>{
  currentState.placedAnswers = deepCopy(currentState.correct);
  updatePlaceholders();
  resultEl.textContent = 'Doğru cevaplar gösterildi. Kural: ' + currentState.ruleText;
  resultEl.style.color = '#2196F3';
});

// Events
document.getElementById('newBtn').addEventListener('click', loadNewQuestion);
document.getElementById('difficulty').addEventListener('change', loadNewQuestion);

// Initial
loadNewQuestion();

</script>
</body>
</html>
